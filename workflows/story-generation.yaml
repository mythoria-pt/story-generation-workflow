# Mythoria – Story Generation Workflow (provider-agnostic)
# Trigger: Pub/Sub topic mythoria-story-requests
#
# Pub/Sub message (base-64 JSON):
#   { "storyId": "<uuid>", "runId": "<uuid>" }
#
# Cloud Run base URL (internal API + AI-Gateway):
#   https://story-generation-workflow-803421888801.europe-west9.run.app
#
main:
  params: [event]

  steps:
    # ───────────────────────────────────────────────
    # 0. Parse event & constants
    # ───────────────────────────────────────────────
    - init:
        assign:
          - payload: ${json.decode(base64.decode(event.data.message.data))}
          - storyId: ${payload.storyId}
          - runId: ${payload.runId}
          - baseUrl: 'https://story-generation-workflow-x2qrlilyyq-od.a.run.app'
          - now: ${time.format(sys.now())}

    # Fetch API key secret (returns base64-encoded data)
    - fetchApiKey:
        call: googleapis.secretmanager.v1.projects.secrets.versions.access
        args:
          name: projects/803421888801/secrets/STORY_GENERATION_WORKFLOW_API_KEY/versions/latest
        result: apiKeySecret

    # Decode secret payload
    - decodeApiKey:
        assign:
          - apiKey: ${text.decode(base64.decode(apiKeySecret.payload.data))}

    # ───────────────────────────────────────────────
    # 1-N. Pipeline wrapped in one try/except
    # ───────────────────────────────────────────────
    - runPipeline:
        try:
          steps:
            # 1. Mark run → running / generate_outline
            - markRunStarted:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    storyId: ${storyId}
                    status: 'running'
                    currentStep: 'generate_outline'
                    startedAt: ${time.format(sys.now())}

            # 2. Generate outline (AI-Gateway)
            - genOutline:
                call: http.request
                args:
                  url: ${baseUrl + "/ai/text/outline"}
                  method: POST
                  auth: { type: OIDC }
                  headers:
                    x-api-key: ${apiKey}
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
                result: outlineResp
            - saveOutline:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId + "/outline"}
                  method: POST
                  auth: { type: OIDC }
                  body:
                    outline: ${outlineResp.body.outline}

            # Extract chapter count from outline
            - extractChapterCount:
                assign:
                  - chapters: ${len(outlineResp.body.outline.chapters)}

            - setChaptersStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'write_chapters'

            # 3. Write chapters sequentially
            - writeChaptersSequential:
                for:
                  range: ${[1, chapters]} # ← native numeric range
                  value: chapterNum
                  steps:
                    - extractChapterInfo:
                        assign:
                          - currentChapter: ${outlineResp.body.outline.chapters[chapterNum - 1]}
                          - chapterTitle: ${currentChapter.chapterTitle}
                          - chapterSynopses: ${currentChapter.chapterSynopses}

                    - genChapter:
                        call: http.request
                        args:
                          url: ${baseUrl + "/ai/text/chapter/" + string(chapterNum)}
                          method: POST
                          auth: { type: OIDC }
                          headers:
                            x-api-key: ${apiKey}
                          body:
                            storyId: ${storyId}
                            runId: ${runId}
                            chapterNumber: ${chapterNum}
                            chapterTitle: ${chapterTitle}
                            chapterSynopses: ${chapterSynopses}
                            chapterCount: ${chapters}
                            outline: ${outlineResp.body.outline}
                        result: chapterResp

                    - saveChapter:
                        call: http.request
                        args:
                          url: ${baseUrl + "/internal/runs/" + runId + "/chapter/" + string(chapterNum)}
                          method: POST
                          auth: { type: OIDC }
                          body:
                            chapter: ${chapterResp.body.chapter}
                            chapterTitle: ${chapterTitle}

            # 4. Generate book front cover
            - setFrontCoverStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'generate_front_cover'

            - getFrontCoverPrompt:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/prompts/" + runId + "/book-cover/front"}
                  method: GET
                  auth: { type: OIDC }
                result: frontCoverPromptResp

            - genFrontCover:
                try:
                  steps:
                    # Initialize retry variables
                    - initFrontCoverRetry:
                        assign:
                          - frontCoverMaxAttempts: 3
                          - frontCoverRetryDelay: 60
                          - frontCoverSuccess: false
                          - frontCoverLastError: null
                          - frontCoverResp: null

                    # Retry loop for front cover generation
                    - frontCoverRetryLoop:
                        for:
                          value: attempt
                          range: ${[1, frontCoverMaxAttempts]}
                          steps:
                            - checkFrontCoverAlreadySuccessful:
                                switch:
                                  - condition: ${frontCoverSuccess}
                                    next: continue
                            - tryFrontCoverGeneration:
                                try:
                                  steps:
                                    - frontCoverRequest:
                                        call: http.request
                                        args:
                                          url: ${baseUrl + "/ai/image"}
                                          method: POST
                                          auth: { type: OIDC }
                                          headers:
                                            x-api-key: ${apiKey}
                                          body:
                                            storyId: ${storyId}
                                            runId: ${runId}
                                            imageType: 'front_cover'
                                            prompt: ${frontCoverPromptResp.body}
                                        result: frontCoverRespTemp
                                    - saveFrontCoverResponse:
                                        assign:
                                          - frontCoverResp: ${frontCoverRespTemp}
                                          - frontCoverSuccess: true
                                except:
                                  as: frontCoverAttemptError
                                  steps:
                                    - saveFrontCoverError:
                                        assign:
                                          - frontCoverLastError: ${frontCoverAttemptError}
                                    - checkFrontCoverErrorType:
                                        switch:
                                          # Safety block (422) - mark as blocked and exit
                                          - condition: ${frontCoverAttemptError.code == 422}
                                            raise: ${frontCoverAttemptError}
                                          # Last attempt - fail
                                          - condition: ${attempt >= frontCoverMaxAttempts}
                                            raise: ${frontCoverAttemptError}
                                          # Retryable error - log and continue to delay
                                    - logFrontCoverRetry:
                                        call: sys.log
                                        args:
                                          severity: WARNING
                                          text: '${"Front cover attempt " + string(attempt) + " failed, retrying after " + string(frontCoverRetryDelay) + "s: " + frontCoverAttemptError.message}'
                                    - delayFrontCoverRetry:
                                        call: sys.sleep
                                        args:
                                          seconds: ${frontCoverRetryDelay}

                    # Check if we succeeded after the loop
                    - checkFrontCoverSuccess:
                        switch:
                          - condition: ${not(frontCoverSuccess)}
                            raise: ${frontCoverLastError}
                except:
                  as: frontCoverError
                  steps:
                    - decideFrontCoverBlocked:
                        switch:
                          - condition: ${frontCoverError.code == 422}
                            next: markRunBlockedFrontCover
                    - rethrowFrontCoverError:
                        raise: ${frontCoverError}
                    - markRunBlockedFrontCover:
                        call: http.request
                        args:
                          url: ${baseUrl + "/internal/runs/" + runId}
                          method: PATCH
                          auth: { type: OIDC }
                          body:
                            status: 'blocked'
                            currentStep: 'blocked'
                            errorMessage: ${frontCoverError.message}
                            endedAt: ${time.format(sys.now())}
                    - returnBlockedFrontCover:
                        return:
                          storyId: ${storyId}
                          runId: ${runId}
                          status: 'blocked'
                          reason: 'safety_blocked_front_cover'

            - storeFrontCoverResult:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId + "/image"}
                  method: POST
                  auth: { type: OIDC }
                  body:
                    imageType: 'front_cover'
                    imageUrl: ${frontCoverResp.body.image.url}
                    filename: ${frontCoverResp.body.image.filename}
                    metadata:
                      format: ${frontCoverResp.body.image.format}
                      size: ${frontCoverResp.body.image.size}

            # 5. Generate book back cover
            - setBackCoverStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'generate_back_cover'

            - getBackCoverPrompt:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/prompts/" + runId + "/book-cover/back"}
                  method: GET
                  auth: { type: OIDC }
                result: backCoverPromptResp

            - genBackCover:
                try:
                  steps:
                    # Initialize retry variables
                    - initBackCoverRetry:
                        assign:
                          - backCoverMaxAttempts: 3
                          - backCoverRetryDelay: 60
                          - backCoverSuccess: false
                          - backCoverLastError: null
                          - backCoverResp: null

                    # Retry loop for back cover generation
                    - backCoverRetryLoop:
                        for:
                          value: attempt
                          range: ${[1, backCoverMaxAttempts]}
                          steps:
                            - checkBackCoverAlreadySuccessful:
                                switch:
                                  - condition: ${backCoverSuccess}
                                    next: continue
                            - tryBackCoverGeneration:
                                try:
                                  steps:
                                    - backCoverRequest:
                                        call: http.request
                                        args:
                                          url: ${baseUrl + "/ai/image"}
                                          method: POST
                                          auth: { type: OIDC }
                                          headers:
                                            x-api-key: ${apiKey}
                                          body:
                                            storyId: ${storyId}
                                            runId: ${runId}
                                            imageType: 'back_cover'
                                            prompt: ${backCoverPromptResp.body}
                                        result: backCoverRespTemp
                                    - saveBackCoverResponse:
                                        assign:
                                          - backCoverResp: ${backCoverRespTemp}
                                          - backCoverSuccess: true
                                except:
                                  as: backCoverAttemptError
                                  steps:
                                    - saveBackCoverError:
                                        assign:
                                          - backCoverLastError: ${backCoverAttemptError}
                                    - checkBackCoverErrorType:
                                        switch:
                                          # Safety block (422) - mark as blocked and exit
                                          - condition: ${backCoverAttemptError.code == 422}
                                            raise: ${backCoverAttemptError}
                                          # Last attempt - fail
                                          - condition: ${attempt >= backCoverMaxAttempts}
                                            raise: ${backCoverAttemptError}
                                          # Retryable error - log and continue to delay
                                    - logBackCoverRetry:
                                        call: sys.log
                                        args:
                                          severity: WARNING
                                          text: '${"Back cover attempt " + string(attempt) + " failed, retrying after " + string(backCoverRetryDelay) + "s: " + backCoverAttemptError.message}'
                                    - delayBackCoverRetry:
                                        call: sys.sleep
                                        args:
                                          seconds: ${backCoverRetryDelay}

                    # Check if we succeeded after the loop
                    - checkBackCoverSuccess:
                        switch:
                          - condition: ${not(backCoverSuccess)}
                            raise: ${backCoverLastError}
                except:
                  as: backCoverError
                  steps:
                    - decideBackCoverBlocked:
                        switch:
                          - condition: ${backCoverError.code == 422}
                            next: markRunBlockedBackCover
                    - rethrowBackCoverError:
                        raise: ${backCoverError}
                    - markRunBlockedBackCover:
                        call: http.request
                        args:
                          url: ${baseUrl + "/internal/runs/" + runId}
                          method: PATCH
                          auth: { type: OIDC }
                          body:
                            status: 'blocked'
                            currentStep: 'blocked'
                            errorMessage: ${backCoverError.message}
                            endedAt: ${time.format(sys.now())}
                    - returnBlockedBackCover:
                        return:
                          storyId: ${storyId}
                          runId: ${runId}
                          status: 'blocked'
                          reason: 'safety_blocked_back_cover'

            - storeBackCoverResult:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId + "/image"}
                  method: POST
                  auth: { type: OIDC }
                  body:
                    imageType: 'back_cover'
                    imageUrl: ${backCoverResp.body.image.url}
                    filename: ${backCoverResp.body.image.filename}
                    metadata:
                      format: ${backCoverResp.body.image.format}
                      size: ${backCoverResp.body.image.size}

            # 6. Generate chapter images sequentially
            - setImagesStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'generate_images'

            - generateImagesSequential:
                for:
                  range: ${[1, chapters]}
                  value: chapterNum
                  steps:
                    - getPrompt:
                        call: http.request
                        args:
                          url: ${baseUrl + "/internal/prompts/" + runId + "/" + string(chapterNum)}
                          method: GET
                          auth: { type: OIDC }
                        result: promptResp
                    - genImage:
                        try:
                          steps:
                            # Initialize retry variables for this chapter
                            - initChapterImageRetry:
                                assign:
                                  - chapterImageMaxAttempts: 3
                                  - chapterImageRetryDelay: 60
                                  - chapterImageSuccess: false
                                  - chapterImageLastError: null
                                  - imageResp: null

                            # Retry loop for chapter image generation
                            - chapterImageRetryLoop:
                                for:
                                  value: attempt
                                  range: ${[1, chapterImageMaxAttempts]}
                                  steps:
                                    - checkChapterImageAlreadySuccessful:
                                        switch:
                                          - condition: ${chapterImageSuccess}
                                            next: continue
                                    - tryChapterImageGeneration:
                                        try:
                                          steps:
                                            - chapterImageRequest:
                                                call: http.request
                                                args:
                                                  url: ${baseUrl + "/ai/image"}
                                                  method: POST
                                                  auth: { type: OIDC }
                                                  headers:
                                                    x-api-key: ${apiKey}
                                                  body:
                                                    storyId: ${storyId}
                                                    runId: ${runId}
                                                    chapterNumber: ${chapterNum}
                                                    imageType: 'chapter'
                                                    prompt: ${promptResp.body}
                                                result: imageRespTemp
                                            - saveChapterImageResponse:
                                                assign:
                                                  - imageResp: ${imageRespTemp}
                                                  - chapterImageSuccess: true
                                        except:
                                          as: chapterImageAttemptError
                                          steps:
                                            - saveChapterImageError:
                                                assign:
                                                  - chapterImageLastError: ${chapterImageAttemptError}
                                            - checkChapterImageErrorType:
                                                switch:
                                                  # Safety block (422) - mark as blocked and exit
                                                  - condition: ${chapterImageAttemptError.code == 422}
                                                    raise: ${chapterImageAttemptError}
                                                  # Last attempt - fail
                                                  - condition: ${attempt >= chapterImageMaxAttempts}
                                                    raise: ${chapterImageAttemptError}
                                                  # Retryable error - log and continue to delay
                                            - logChapterImageRetry:
                                                call: sys.log
                                                args:
                                                  severity: WARNING
                                                  text: '${"Chapter " + string(chapterNum) + " image attempt " + string(attempt) + " failed, retrying after " + string(chapterImageRetryDelay) + "s: " + chapterImageAttemptError.message}'
                                            - delayChapterImageRetry:
                                                call: sys.sleep
                                                args:
                                                  seconds: ${chapterImageRetryDelay}

                            # Check if we succeeded after the loop
                            - checkChapterImageSuccess:
                                switch:
                                  - condition: ${not(chapterImageSuccess)}
                                    raise: ${chapterImageLastError}
                        except:
                          as: chapterImageError
                          steps:
                            - decideChapterImageBlocked:
                                switch:
                                  - condition: ${chapterImageError.code == 422}
                                    next: markRunBlockedChapterImage
                            - rethrowChapterImageError:
                                raise: ${chapterImageError}
                            - markRunBlockedChapterImage:
                                call: http.request
                                args:
                                  url: ${baseUrl + "/internal/runs/" + runId}
                                  method: PATCH
                                  auth: { type: OIDC }
                                  body:
                                    status: 'blocked'
                                    currentStep: 'blocked'
                                    errorMessage: ${chapterImageError.message}
                                    endedAt: ${time.format(sys.now())}
                            - returnBlockedChapterImage:
                                return:
                                  storyId: ${storyId}
                                  runId: ${runId}
                                  status: 'blocked'
                                  reason: 'safety_blocked_chapter_image'
                    - storeImageResult:
                        call: http.request
                        args:
                          url: ${baseUrl + "/internal/runs/" + runId + "/image"}
                          method: POST
                          auth: { type: OIDC }
                          body:
                            chapterNumber: ${chapterNum}
                            imageType: 'chapter'
                            imageUrl: ${imageResp.body.image.url}
                            filename: ${imageResp.body.image.filename}
                            metadata:
                              format: ${imageResp.body.image.format}
                              size: ${imageResp.body.image.size}

            # 8. Mark run completed
            - clearContext:
                call: http.request
                args:
                  url: ${baseUrl + "/ai/text/context/clear"}
                  method: POST
                  auth: { type: OIDC }
                  headers:
                    x-api-key: ${apiKey}
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
            - markCompleted:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    status: 'completed'
                    currentStep: 'done'
                    endedAt: ${time.format(sys.now())}

            - return_result:
                return:
                  storyId: ${storyId}
                  runId: ${runId}
                  status: 'completed'

        except:
          as: wfError
          steps:
            - markFailedRun:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    status: 'failed'
                    currentStep: 'unknown'
                    errorMessage: ${wfError.message}
                    endedAt: ${time.format(sys.now())}

            - rethrow:
                raise: ${wfError}

# Mythoria – Story Generation Workflow (provider-agnostic)
# Trigger: Pub/Sub topic mythoria.story.requests
#
# Pub/Sub message (base-64 JSON):
#   { "storyId": "<uuid>", "runId": "<uuid>" }
#
# Cloud Run base URL (internal API + AI-Gateway):
#   https://story-generation-workflow-803421888801.europe-west9.run.app
#
main:
  params: [event]

  steps:
    # ───────────────────────────────────────────────
    # 0. Parse event & constants
    # ───────────────────────────────────────────────
    - init:
        assign:
          - payload:  ${json.decode(base64.decode(event.data))}
          - storyId:  ${payload.storyId}
          - runId:    ${payload.runId}
          - baseUrl:  "https://097a-2001-818-de82-dd00-d993-94dc-2153-facd.ngrok-free.app"
          - now:      ${time.format(sys.now())}

    # ───────────────────────────────────────────────
    # 1-N. Pipeline wrapped in one try/except
    # ───────────────────────────────────────────────
    - runPipeline:
        try:
          steps:
            # 1. Mark run → running / generate_outline
            - markRunStarted:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    status:       "running"
                    currentStep: "generate_outline"
                    startedAt:   ${time.format(sys.now())}

            # 2. Generate outline (AI-Gateway)
            - genOutline:
                call: http.request
                args:
                  url:    ${baseUrl + "/ai/text/outline"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
                result: outlineResp
            - saveOutline:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId + "/outline"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    outline: ${outlineResp.body.outline}

            # Extract chapter count from outline
            - extractChapterCount:
                assign:
                  - chapters: ${len(outlineResp.body.outline.chapters)}

            - setChaptersStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "write_chapters"

            # 3. Write chapters sequentially
            - writeChaptersSequential:
                for:
                  range: ${[1, chapters]}   # ← native numeric range
                  value: chapterNum
                  steps:
                    - extractChapterInfo:
                        assign:
                          - currentChapter: ${outlineResp.body.outline.chapters[chapterNum - 1]}
                          - chapterTitle: ${currentChapter.chapterTitle}
                          - chapterSynopses: ${currentChapter.chapterSynopses}

                    - genChapter:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/ai/text/chapter/" + string(chapterNum)}
                          method: POST
                          auth:   { type: OIDC }
                          body:
                            storyId: ${storyId}
                            runId: ${runId}
                            chapterNumber: ${chapterNum}
                            chapterTitle: ${chapterTitle}
                            chapterSynopses: ${chapterSynopses}
                            chapterCount: ${chapters}
                            outline: ${outlineResp.body.outline}
                        result: chapterResp

                    - saveChapter:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/runs/" + runId + "/chapter/" + string(chapterNum)}
                          method: POST
                          auth:   { type: OIDC }
                          body: ${chapterResp.body}

            # 4. Generate book front cover
            - setFrontCoverStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_front_cover"

            - getFrontCoverPrompt:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/prompts/" + runId + "/book-cover/front"}
                  method: GET
                  auth:   { type: OIDC }
                result: frontCoverPromptResp

            - genFrontCover:
                call: http.request
                args:
                  url:    ${baseUrl + "/ai/image"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
                    imageType: "front_cover"
                    prompt: ${frontCoverPromptResp.body}
                result: frontCoverResp

            # 5. Generate book back cover
            - setBackCoverStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_back_cover"

            - getBackCoverPrompt:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/prompts/" + runId + "/book-cover/back"}
                  method: GET
                  auth:   { type: OIDC }
                result: backCoverPromptResp

            - genBackCover:
                call: http.request
                args:
                  url:    ${baseUrl + "/ai/image"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
                    imageType: "back_cover"
                    prompt: ${backCoverPromptResp.body}
                result: backCoverResp

            # 6. Generate chapter images sequentially
            - setImagesStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_images"

            - generateImagesSequential:
                for:
                  range: ${[1, chapters]}   # ← native numeric range
                  value: chapterNum
                  steps:
                    - getPrompt:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/prompts/" + runId + "/" + string(chapterNum)}
                          method: GET
                          auth:   { type: OIDC }
                        result: promptResp
                    - genImage:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/ai/image"}
                          method: POST
                          auth:   { type: OIDC }
                          body:
                            storyId: ${storyId}
                            runId: ${runId}
                            chapterNumber: ${chapterNum}
                            imageType: "chapter"
                            prompt: ${promptResp.body}
                        result: imageResp

            # 7. Assemble HTML & PDF
            - setAssembleStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "assemble"

            - assemble:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/assemble/" + runId}
                  method: POST
                  auth:   { type: OIDC }
                result: assembleResp
            
            # 8. Generate audio book
            - setTTSStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_audiobook"

            - generateAudiobook:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/tts/" + runId}
                  method: POST
                  auth:   { type: OIDC }
                result: audiobookResp

            # 9. Mark run completed
            - markCompleted:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    status:      "completed"
                    currentStep: "done"
                    endedAt:     ${time.format(sys.now())}

            - return_result:
                return:
                  storyId: ${storyId}
                  runId:   ${runId}
                  status:  "completed"

        except:
          as: wfError
          steps:
            - markFailedRun:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    status:       "failed"
                    currentStep:  ${default(wfError.step, "unknown")}
                    errorMessage: ${string(wfError)}
                    endedAt:      ${time.format(sys.now())}

            - rethrow:
                raise: ${wfError}
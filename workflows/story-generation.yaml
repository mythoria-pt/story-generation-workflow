# Mythoria – Story Generation Workflow (provider-agnostic)
# Trigger: Pub/Sub topic mythoria-story-requests
#
# Pub/Sub message (base-64 JSON):
#   { "storyId": "<uuid>", "runId": "<uuid>" }
#
# Cloud Run base URL (internal API + AI-Gateway):
#   https://story-generation-workflow-803421888801.europe-west9.run.app
#
main:
  params: [event]

  steps:
    # ───────────────────────────────────────────────
    # 0. Parse event & constants
    # ───────────────────────────────────────────────
    - init:
        assign:
          - payload: ${json.decode(base64.decode(event.data.message.data))}
          - storyId: ${payload.storyId}
          - runId: ${payload.runId}
          - baseUrl: 'https://story-generation-workflow-803421888801.europe-west9.run.app'
          - now: ${time.format(sys.now())}

    # Fetch API key secret (returns base64-encoded data)
    - fetchApiKey:
        call: googleapis.secretmanager.v1.projects.secrets.versions.access
        args:
          name: projects/803421888801/secrets/STORY_GENERATION_WORKFLOW_API_KEY/versions/latest
        result: apiKeySecret

    # Decode secret payload
    - decodeApiKey:
        assign:
          - apiKey: ${text.decode(base64.decode(apiKeySecret.payload.data))}

    # ───────────────────────────────────────────────
    # 1-N. Pipeline wrapped in one try/except
    # ───────────────────────────────────────────────
    - runPipeline:
        try:
          steps:
            # 1. Mark run → running / generate_outline
            - markRunStarted:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    storyId: ${storyId}
                    status: 'running'
                    currentStep: 'generate_outline'
                    startedAt: ${time.format(sys.now())}

            # 2. Generate outline (AI-Gateway)
            - genOutline:
                try:
                  steps:
                    - initOutlineRetry:
                        assign:
                          - outlineMaxAttempts: 3
                          - outlineRetryDelay: 60
                          - outlineSuccess: false
                          - outlineLastError: null
                          - outlineResp: null

                    - outlineRetryLoop:
                        for:
                          value: attempt
                          range: ${[1, outlineMaxAttempts]}
                          steps:
                            - checkOutlineAlreadySuccessful:
                                switch:
                                  - condition: ${outlineSuccess}
                                    next: continue
                            - tryOutlineGeneration:
                                try:
                                  steps:
                                    - outlineRequest:
                                        call: http.request
                                        args:
                                          url: ${baseUrl + "/ai/text/outline"}
                                          method: POST
                                          auth: { type: OIDC }
                                          headers:
                                            x-api-key: ${apiKey}
                                          body:
                                            storyId: ${storyId}
                                            runId: ${runId}
                                        result: outlineRespTemp
                                    - saveOutlineResponse:
                                        assign:
                                          - outlineResp: ${outlineRespTemp}
                                          - outlineSuccess: true
                                except:
                                  as: outlineAttemptError
                                  steps:
                                    - saveOutlineError:
                                        assign:
                                          - outlineLastError: ${outlineAttemptError}
                                    - logOutlineRetry:
                                        call: sys.log
                                        args:
                                          severity: WARNING
                                          text: '${"Outline attempt " + string(attempt) + " failed, retrying after " + string(outlineRetryDelay) + "s: " + outlineAttemptError.message}'
                                    - delayOutlineRetry:
                                        call: sys.sleep
                                        args:
                                          seconds: ${outlineRetryDelay}

                except:
                  as: outlineError
                  steps:
                    - logOutlineFailure:
                        call: sys.log
                        args:
                          severity: WARNING
                          text: '${"Outline generation failed after retries: " + outlineError.message}'
                    - raiseOutlineFailure:
                        raise: ${outlineError}

            - handleOutlineOutcome:
                switch:
                  - condition: ${outlineSuccess}
                    steps:
                      - saveOutline:
                          call: http.request
                          args:
                            url: ${baseUrl + "/internal/runs/" + runId + "/outline"}
                            method: POST
                            auth: { type: OIDC }
                            body:
                              outline: ${outlineResp.body.outline}

                      - extractChapterCount:
                          assign:
                            - chapters: ${len(outlineResp.body.outline.chapters)}

                      - setChaptersStep:
                          call: http.request
                          args:
                            url: ${baseUrl + "/internal/runs/" + runId}
                            method: PATCH
                            auth: { type: OIDC }
                            body:
                              currentStep: 'write_chapters'
                  - condition: ${not(outlineSuccess)}
                    steps:
                      - logOutlineUnavailable:
                          call: sys.log
                          args:
                            severity: WARNING
                            text: '${"Outline unavailable after retries; last error: " + if(outlineLastError != null, outlineLastError.message, "unknown")}'
                      - raiseOutlineUnavailable:
                          raise: 'Outline generation failed after retries'

            # 3. Write chapters sequentially
            - writeChaptersSequential:
                for:
                  range: ${[1, chapters]} # ← native numeric range
                  value: chapterNum
                  steps:
                    - extractChapterInfo:
                        assign:
                          - currentChapter: ${outlineResp.body.outline.chapters[chapterNum - 1]}
                          - chapterTitle: ${currentChapter.chapterTitle}
                          - chapterSynopses: ${currentChapter.chapterSynopses}

                    - initChapterTextRetry:
                        assign:
                          - chapterTextMaxAttempts: 3
                          - chapterTextRetryDelay: 60
                          - chapterTextSuccess: false
                          - chapterTextLastError: null
                          - chapterResp: null

                    - chapterTextRetryLoop:
                        for:
                          value: attempt
                          range: ${[1, chapterTextMaxAttempts]}
                          steps:
                            - checkChapterTextAlreadySuccessful:
                                switch:
                                  - condition: ${chapterTextSuccess}
                                    next: continue
                            - tryChapterTextGeneration:
                                try:
                                  steps:
                                    - chapterRequest:
                                        call: http.request
                                        args:
                                          url: ${baseUrl + "/ai/text/chapter/" + string(chapterNum)}
                                          method: POST
                                          auth: { type: OIDC }
                                          headers:
                                            x-api-key: ${apiKey}
                                          body:
                                            storyId: ${storyId}
                                            runId: ${runId}
                                            chapterNumber: ${chapterNum}
                                            chapterTitle: ${chapterTitle}
                                            chapterSynopses: ${chapterSynopses}
                                            chapterCount: ${chapters}
                                            outline: ${outlineResp.body.outline}
                                        result: chapterRespTemp
                                    - saveChapterTextResponse:
                                        assign:
                                          - chapterResp: ${chapterRespTemp}
                                          - chapterTextSuccess: true
                                except:
                                  as: chapterTextAttemptError
                                  steps:
                                    - saveChapterTextError:
                                        assign:
                                          - chapterTextLastError: ${chapterTextAttemptError}
                                    - logChapterTextRetry:
                                        call: sys.log
                                        args:
                                          severity: WARNING
                                          text: '${"Chapter " + string(chapterNum) + " text attempt " + string(attempt) + " failed, retrying after " + string(chapterTextRetryDelay) + "s: " + chapterTextAttemptError.message}'
                                    - delayChapterTextRetry:
                                        call: sys.sleep
                                        args:
                                          seconds: ${chapterTextRetryDelay}

                    - handleChapterTextOutcome:
                        switch:
                          - condition: ${chapterTextSuccess}
                            steps:
                              - saveChapter:
                                  call: http.request
                                  args:
                                    url: ${baseUrl + "/internal/runs/" + runId + "/chapter/" + string(chapterNum)}
                                    method: POST
                                    auth: { type: OIDC }
                                    body:
                                      chapter: ${chapterResp.body.chapter}
                                      chapterTitle: ${chapterTitle}
                          - condition: ${not(chapterTextSuccess)}
                            steps:
                              - logChapterTextFailure:
                                  call: sys.log
                                  args:
                                    severity: WARNING
                                    text: '${"Chapter text unavailable after retries for chapter " + string(chapterNum) + "; last error: " + if(chapterTextLastError != null, chapterTextLastError.message, "unknown")}'
                              - raiseChapterTextFailure:
                                  raise: ${"Chapter text generation failed after retries for chapter " + string(chapterNum)}

            # 4. Generate book front cover
            - setFrontCoverStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'generate_front_cover'

            - getFrontCoverPrompt:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/prompts/" + runId + "/book-cover/front"}
                  method: GET
                  auth: { type: OIDC }
                result: frontCoverPromptResp

            - genFrontCover:
                try:
                  steps:
                    # Initialize retry variables
                    - initFrontCoverRetry:
                        assign:
                          - frontCoverMaxAttempts: 3
                          - frontCoverRetryDelay: 60
                          - frontCoverSuccess: false
                          - frontCoverLastError: null
                          - frontCoverResp: null

                    # Retry loop for front cover generation
                    - frontCoverRetryLoop:
                        for:
                          value: attempt
                          range: ${[1, frontCoverMaxAttempts]}
                          steps:
                            - checkFrontCoverAlreadySuccessful:
                                switch:
                                  - condition: ${frontCoverSuccess}
                                    next: continue
                            - tryFrontCoverGeneration:
                                try:
                                  steps:
                                    - frontCoverRequest:
                                        call: http.request
                                        args:
                                          url: ${baseUrl + "/ai/image"}
                                          method: POST
                                          auth: { type: OIDC }
                                          headers:
                                            x-api-key: ${apiKey}
                                          body:
                                            storyId: ${storyId}
                                            runId: ${runId}
                                            imageType: 'front_cover'
                                            prompt: ${frontCoverPromptResp.body}
                                        result: frontCoverRespTemp
                                    - saveFrontCoverResponse:
                                        assign:
                                          - frontCoverResp: ${frontCoverRespTemp}
                                          - frontCoverSuccess: true
                                except:
                                  as: frontCoverAttemptError
                                  steps:
                                    - saveFrontCoverError:
                                        assign:
                                          - frontCoverLastError: ${frontCoverAttemptError}
                                    - logFrontCoverRetry:
                                        call: sys.log
                                        args:
                                          severity: WARNING
                                          text: '${"Front cover attempt " + string(attempt) + " failed, retrying after " + string(frontCoverRetryDelay) + "s: " + frontCoverAttemptError.message}'
                                    - delayFrontCoverRetry:
                                        call: sys.sleep
                                        args:
                                          seconds: ${frontCoverRetryDelay}

                except:
                  as: frontCoverError
                  steps:
                    - logFrontCoverFailure:
                        call: sys.log
                        args:
                          severity: WARNING
                          text: '${"Front cover generation failed after retries: " + frontCoverError.message}'
                    - flagFrontCoverFailure:
                        assign:
                          - frontCoverFailureReason: ${frontCoverError.message}
                          - frontCoverFailureCode: ${default(map.get(frontCoverError, "code"), "unknown")}

            - handleFrontCoverOutcome:
                switch:
                  - condition: ${frontCoverSuccess}
                    steps:
                      - storeFrontCoverResult:
                          call: http.request
                          args:
                            url: ${baseUrl + "/internal/runs/" + runId + "/image"}
                            method: POST
                            auth: { type: OIDC }
                            body:
                              imageType: 'front_cover'
                              imageUrl: ${frontCoverResp.body.image.url}
                              filename: ${frontCoverResp.body.image.filename}
                              metadata:
                                format: ${frontCoverResp.body.image.format}
                                size: ${frontCoverResp.body.image.size}
                  - condition: ${not(frontCoverSuccess)}
                    steps:
                      - captureFrontCoverFailure:
                          assign:
                            - frontCoverFailureReason: ${if(frontCoverLastError != null, frontCoverLastError.message, "unknown")}
                            - frontCoverFailureCode: ${if(frontCoverLastError != null, frontCoverLastError.code, null)}
                      - logFrontCoverSkip:
                          call: sys.log
                          args:
                            severity: WARNING
                            text: '${"Front cover image unavailable after retries; continuing pipeline. Last error: " + if(frontCoverLastError != null, frontCoverLastError.message, "unknown")}'

            # 5. Generate book back cover
            - setBackCoverStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'generate_back_cover'

            - getBackCoverPrompt:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/prompts/" + runId + "/book-cover/back"}
                  method: GET
                  auth: { type: OIDC }
                result: backCoverPromptResp

            - genBackCover:
                try:
                  steps:
                    # Initialize retry variables
                    - initBackCoverRetry:
                        assign:
                          - backCoverMaxAttempts: 3
                          - backCoverRetryDelay: 60
                          - backCoverSuccess: false
                          - backCoverLastError: null
                          - backCoverResp: null

                    # Retry loop for back cover generation
                    - backCoverRetryLoop:
                        for:
                          value: attempt
                          range: ${[1, backCoverMaxAttempts]}
                          steps:
                            - checkBackCoverAlreadySuccessful:
                                switch:
                                  - condition: ${backCoverSuccess}
                                    next: continue
                            - tryBackCoverGeneration:
                                try:
                                  steps:
                                    - backCoverRequest:
                                        call: http.request
                                        args:
                                          url: ${baseUrl + "/ai/image"}
                                          method: POST
                                          auth: { type: OIDC }
                                          headers:
                                            x-api-key: ${apiKey}
                                          body:
                                            storyId: ${storyId}
                                            runId: ${runId}
                                            imageType: 'back_cover'
                                            prompt: ${backCoverPromptResp.body}
                                        result: backCoverRespTemp
                                    - saveBackCoverResponse:
                                        assign:
                                          - backCoverResp: ${backCoverRespTemp}
                                          - backCoverSuccess: true
                                except:
                                  as: backCoverAttemptError
                                  steps:
                                    - saveBackCoverError:
                                        assign:
                                          - backCoverLastError: ${backCoverAttemptError}
                                    - logBackCoverRetry:
                                        call: sys.log
                                        args:
                                          severity: WARNING
                                          text: '${"Back cover attempt " + string(attempt) + " failed, retrying after " + string(backCoverRetryDelay) + "s: " + backCoverAttemptError.message}'
                                    - delayBackCoverRetry:
                                        call: sys.sleep
                                        args:
                                          seconds: ${backCoverRetryDelay}
                except:
                  as: backCoverError
                  steps:
                    - logBackCoverFailure:
                        call: sys.log
                        args:
                          severity: WARNING
                          text: '${"Back cover generation failed after retries: " + backCoverError.message}'
                    - flagBackCoverFailure:
                        assign:
                          - backCoverFailureReason: ${backCoverError.message}
                          - backCoverFailureCode: ${default(map.get(backCoverError, "code"), "unknown")}

            - handleBackCoverOutcome:
                switch:
                  - condition: ${backCoverSuccess}
                    steps:
                      - storeBackCoverResult:
                          call: http.request
                          args:
                            url: ${baseUrl + "/internal/runs/" + runId + "/image"}
                            method: POST
                            auth: { type: OIDC }
                            body:
                              imageType: 'back_cover'
                              imageUrl: ${backCoverResp.body.image.url}
                              filename: ${backCoverResp.body.image.filename}
                              metadata:
                                format: ${backCoverResp.body.image.format}
                                size: ${backCoverResp.body.image.size}
                  - condition: ${not(backCoverSuccess)}
                    steps:
                      - captureBackCoverFailure:
                          assign:
                            - backCoverFailureReason: ${if(backCoverLastError != null, backCoverLastError.message, "unknown")}
                            - backCoverFailureCode: ${if(backCoverLastError != null, backCoverLastError.code, null)}
                      - logBackCoverSkip:
                          call: sys.log
                          args:
                            severity: WARNING
                            text: '${"Back cover image unavailable after retries; continuing pipeline. Last error: " + if(backCoverLastError != null, backCoverLastError.message, "unknown")}'

            # 6. Generate chapter images sequentially
            - setImagesStep:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    currentStep: 'generate_images'

            - generateImagesSequential:
                for:
                  range: ${[1, chapters]}
                  value: chapterNum
                  steps:
                    - getPrompt:
                        call: http.request
                        args:
                          url: ${baseUrl + "/internal/prompts/" + runId + "/" + string(chapterNum)}
                          method: GET
                          auth: { type: OIDC }
                        result: promptResp
                    - genImage:
                        try:
                          steps:
                            # Initialize retry variables for this chapter
                            - initChapterImageRetry:
                                assign:
                                  - chapterImageMaxAttempts: 3
                                  - chapterImageRetryDelay: 60
                                  - chapterImageSuccess: false
                                  - chapterImageLastError: null
                                  - imageResp: null

                            # Retry loop for chapter image generation
                            - chapterImageRetryLoop:
                                for:
                                  value: attempt
                                  range: ${[1, chapterImageMaxAttempts]}
                                  steps:
                                    - checkChapterImageAlreadySuccessful:
                                        switch:
                                          - condition: ${chapterImageSuccess}
                                            next: continue
                                    - tryChapterImageGeneration:
                                        try:
                                          steps:
                                            - chapterImageRequest:
                                                call: http.request
                                                args:
                                                  url: ${baseUrl + "/ai/image"}
                                                  method: POST
                                                  auth: { type: OIDC }
                                                  headers:
                                                    x-api-key: ${apiKey}
                                                  body:
                                                    storyId: ${storyId}
                                                    runId: ${runId}
                                                    chapterNumber: ${chapterNum}
                                                    imageType: 'chapter'
                                                    prompt: ${promptResp.body}
                                                result: imageRespTemp
                                            - saveChapterImageResponse:
                                                assign:
                                                  - imageResp: ${imageRespTemp}
                                                  - chapterImageSuccess: true
                                        except:
                                          as: chapterImageAttemptError
                                          steps:
                                            - saveChapterImageError:
                                                assign:
                                                  - chapterImageLastError: ${chapterImageAttemptError}
                                            - logChapterImageRetry:
                                                call: sys.log
                                                args:
                                                  severity: WARNING
                                                  text: '${"Chapter " + string(chapterNum) + " image attempt " + string(attempt) + " failed, retrying after " + string(chapterImageRetryDelay) + "s: " + chapterImageAttemptError.message}'
                                            - delayChapterImageRetry:
                                                call: sys.sleep
                                                args:
                                                  seconds: ${chapterImageRetryDelay}

                        except:
                          as: chapterImageError
                          steps:
                            - logChapterImageFailure:
                                call: sys.log
                                args:
                                  severity: WARNING
                                  text: '${"Chapter " + string(chapterNum) + " image failed unexpectedly: " + chapterImageError.message}'
                            - flagChapterImageFailure:
                                assign:
                                  - chapterImageFailureReason: ${chapterImageError.message}
                                  - chapterImageFailureCode: ${default(map.get(chapterImageError, "code"), "unknown")}
                    - handleChapterImageOutcome:
                        switch:
                          - condition: ${chapterImageSuccess}
                            steps:
                              - storeImageResult:
                                  call: http.request
                                  args:
                                    url: ${baseUrl + "/internal/runs/" + runId + "/image"}
                                    method: POST
                                    auth: { type: OIDC }
                                    body:
                                      chapterNumber: ${chapterNum}
                                      imageType: 'chapter'
                                      imageUrl: ${imageResp.body.image.url}
                                      filename: ${imageResp.body.image.filename}
                                      metadata:
                                        format: ${imageResp.body.image.format}
                                        size: ${imageResp.body.image.size}
                          - condition: ${not(chapterImageSuccess)}
                            steps:
                              - captureChapterImageFailure:
                                  assign:
                                    - chapterImageFailureReason: ${if(chapterImageLastError != null, chapterImageLastError.message, "unknown")}
                                    - chapterImageFailureCode: ${if(chapterImageLastError != null, chapterImageLastError.code, null)}
                              - logChapterImageSkip:
                                  call: sys.log
                                  args:
                                    severity: WARNING
                                    text: '${"Skipping image persistence for chapter " + string(chapterNum) + " due to repeated failures. Last error: " + if(chapterImageLastError != null, chapterImageLastError.message, "unknown")}'

            # 8. Mark run completed
            - clearContext:
                call: http.request
                args:
                  url: ${baseUrl + "/ai/text/context/clear"}
                  method: POST
                  auth: { type: OIDC }
                  headers:
                    x-api-key: ${apiKey}
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
            - markCompleted:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    status: 'completed'
                    currentStep: 'done'
                    endedAt: ${time.format(sys.now())}

            - return_result:
                return:
                  storyId: ${storyId}
                  runId: ${runId}
                  status: 'completed'

        except:
          as: wfError
          steps:
            - markFailedRun:
                call: http.request
                args:
                  url: ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth: { type: OIDC }
                  body:
                    status: 'failed'
                    currentStep: 'unknown'
                    errorMessage: ${wfError.message}
                    endedAt: ${time.format(sys.now())}

            - rethrow:
                raise: ${wfError}

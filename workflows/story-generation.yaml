# Mythoria – Story Generation Workflow (provider-agnostic)
# Trigger: Pub/Sub topic mythoria-story-requests
#
# Pub/Sub message (base-64 JSON):
#   { "storyId": "<uuid>", "runId": "<uuid>" }
#
# Cloud Run base URL (internal API + AI-Gateway):
#   https://story-generation-workflow-803421888801.europe-west9.run.app
#
main:
  params: [event]

  steps:
    # ───────────────────────────────────────────────
    # 0. Parse event & constants
    # ───────────────────────────────────────────────
    - init:
        assign:
          - payload:  ${json.decode(base64.decode(event.data.message.data))}
          - storyId:  ${payload.storyId}
          - runId:    ${payload.runId}
          - baseUrl:  "https://story-generation-workflow-x2qrlilyyq-od.a.run.app"
          - now:      ${time.format(sys.now())}

    # Fetch API key secret (returns base64-encoded data)
    - fetchApiKey:
        call: googleapis.secretmanager.v1.projects.secrets.versions.access
        args:
          name: projects/803421888801/secrets/STORY_GENERATION_WORKFLOW_API_KEY/versions/latest
        result: apiKeySecret

    # Decode secret payload
    - decodeApiKey:
        assign:
          - apiKey: ${text.decode(base64.decode(apiKeySecret.payload.data))}

    # ───────────────────────────────────────────────
    # 1-N. Pipeline wrapped in one try/except
    # ───────────────────────────────────────────────
    - runPipeline:
        try:
          steps:
            # 1. Mark run → running / generate_outline
            - markRunStarted:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    storyId:      ${storyId}
                    status:       "running"
                    currentStep: "generate_outline"
                    startedAt:   ${time.format(sys.now())}

            # 2. Generate outline (AI-Gateway)
            - genOutline:
                call: http.request
                args:
                  url:    ${baseUrl + "/ai/text/outline"}
                  method: POST
                  auth:   { type: OIDC }
                  headers:
                    x-api-key: ${apiKey}
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
                result: outlineResp
            - saveOutline:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId + "/outline"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    outline: ${outlineResp.body.outline}

            # Extract chapter count from outline
            - extractChapterCount:
                assign:
                  - chapters: ${len(outlineResp.body.outline.chapters)}

            - setChaptersStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "write_chapters"

            # 3. Write chapters sequentially
            - writeChaptersSequential:
                for:
                  range: ${[1, chapters]}   # ← native numeric range
                  value: chapterNum
                  steps:
                    - extractChapterInfo:
                        assign:
                          - currentChapter: ${outlineResp.body.outline.chapters[chapterNum - 1]}
                          - chapterTitle: ${currentChapter.chapterTitle}
                          - chapterSynopses: ${currentChapter.chapterSynopses}

                    - genChapter:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/ai/text/chapter/" + string(chapterNum)}
                          method: POST
                          auth:   { type: OIDC }
                          headers:
                            x-api-key: ${apiKey}
                          body:
                            storyId: ${storyId}
                            runId: ${runId}
                            chapterNumber: ${chapterNum}
                            chapterTitle: ${chapterTitle}
                            chapterSynopses: ${chapterSynopses}
                            chapterCount: ${chapters}
                            outline: ${outlineResp.body.outline}
                        result: chapterResp

                    - saveChapter:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/runs/" + runId + "/chapter/" + string(chapterNum)}
                          method: POST
                          auth:   { type: OIDC }
                          body: 
                            chapter: ${chapterResp.body.chapter}
                            chapterTitle: ${chapterTitle}

            # 4. Generate book front cover
            - setFrontCoverStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_front_cover"

            - getFrontCoverPrompt:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/prompts/" + runId + "/book-cover/front"}
                  method: GET
                  auth:   { type: OIDC }
                result: frontCoverPromptResp

            - genFrontCover:
                try:
                  steps:
                    - frontCoverRequest:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/ai/image"}
                          method: POST
                          auth:   { type: OIDC }
                          headers:
                            x-api-key: ${apiKey}
                          body:
                            storyId: ${storyId}
                            runId: ${runId}
                            imageType: "front_cover"
                            prompt: ${frontCoverPromptResp.body}
                        result: frontCoverResp
                except:
                  as: frontCoverError
                  steps:
                    - decideFrontCoverBlocked:
                        switch:
                          - condition: ${frontCoverError.code == 422}
                            next: markRunBlockedFrontCover
                    - rethrowFrontCoverError:
                        raise: ${frontCoverError}
                    - markRunBlockedFrontCover:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/runs/" + runId}
                          method: PATCH
                          auth:   { type: OIDC }
                          body:
                            status:       "blocked"
                            currentStep:  "blocked"
                            errorMessage: ${frontCoverError.message}
                            endedAt:      ${time.format(sys.now())}
                    - returnBlockedFrontCover:
                        return:
                          storyId: ${storyId}
                          runId:   ${runId}
                          status:  "blocked"
                          reason:  "safety_blocked_front_cover"

            - storeFrontCoverResult:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId + "/image"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    imageType: "front_cover"
                    imageUrl: ${frontCoverResp.body.image.url}
                    filename: ${frontCoverResp.body.image.filename}
                    metadata:
                      format: ${frontCoverResp.body.image.format}
                      size: ${frontCoverResp.body.image.size}

            # 5. Generate book back cover
            - setBackCoverStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_back_cover"

            - getBackCoverPrompt:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/prompts/" + runId + "/book-cover/back"}
                  method: GET
                  auth:   { type: OIDC }
                result: backCoverPromptResp

            - genBackCover:
                try:
                  steps:
                    - backCoverRequest:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/ai/image"}
                          method: POST
                          auth:   { type: OIDC }
                          headers:
                            x-api-key: ${apiKey}
                          body:
                            storyId: ${storyId}
                            runId: ${runId}
                            imageType: "back_cover"
                            prompt: ${backCoverPromptResp.body}
                        result: backCoverResp
                except:
                  as: backCoverError
                  steps:
                    - decideBackCoverBlocked:
                        switch:
                          - condition: ${backCoverError.code == 422}
                            next: markRunBlockedBackCover
                    - rethrowBackCoverError:
                        raise: ${backCoverError}
                    - markRunBlockedBackCover:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/runs/" + runId}
                          method: PATCH
                          auth:   { type: OIDC }
                          body:
                            status:       "blocked"
                            currentStep:  "blocked"
                            errorMessage: ${backCoverError.message}
                            endedAt:      ${time.format(sys.now())}
                    - returnBlockedBackCover:
                        return:
                          storyId: ${storyId}
                          runId:   ${runId}
                          status:  "blocked"
                          reason:  "safety_blocked_back_cover"

            - storeBackCoverResult:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId + "/image"}
                  method: POST
                  auth:   { type: OIDC }
                  body:
                    imageType: "back_cover"
                    imageUrl: ${backCoverResp.body.image.url}
                    filename: ${backCoverResp.body.image.filename}
                    metadata:
                      format: ${backCoverResp.body.image.format}
                      size: ${backCoverResp.body.image.size}

            # 6. Generate chapter images sequentially
            - setImagesStep:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    currentStep: "generate_images"

            - generateImagesSequential:
                for:
                  range: ${[1, chapters]}
                  value: chapterNum
                  steps:
                    - getPrompt:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/prompts/" + runId + "/" + string(chapterNum)}
                          method: GET
                          auth:   { type: OIDC }
                        result: promptResp
                    - genImage:
                        try:
                          steps:
                            - chapterImageRequest:
                                call: http.request
                                args:
                                  url:    ${baseUrl + "/ai/image"}
                                  method: POST
                                  auth:   { type: OIDC }
                                  headers:
                                    x-api-key: ${apiKey}
                                  body:
                                    storyId: ${storyId}
                                    runId: ${runId}
                                    chapterNumber: ${chapterNum}
                                    imageType: "chapter"
                                    prompt: ${promptResp.body}
                                result: imageResp
                        except:
                          as: chapterImageError
                          steps:
                            - decideChapterImageBlocked:
                                switch:
                                  - condition: ${chapterImageError.code == 422}
                                    next: markRunBlockedChapterImage
                            - rethrowChapterImageError:
                                raise: ${chapterImageError}
                            - markRunBlockedChapterImage:
                                call: http.request
                                args:
                                  url:    ${baseUrl + "/internal/runs/" + runId}
                                  method: PATCH
                                  auth:   { type: OIDC }
                                  body:
                                    status:       "blocked"
                                    currentStep:  "blocked"
                                    errorMessage: ${chapterImageError.message}
                                    endedAt:      ${time.format(sys.now())}
                            - returnBlockedChapterImage:
                                return:
                                  storyId: ${storyId}
                                  runId:   ${runId}
                                  status:  "blocked"
                                  reason:  "safety_blocked_chapter_image"
                    - storeImageResult:
                        call: http.request
                        args:
                          url:    ${baseUrl + "/internal/runs/" + runId + "/image"}
                          method: POST
                          auth:   { type: OIDC }
                          body:
                            chapterNumber: ${chapterNum}
                            imageType: "chapter"
                            imageUrl: ${imageResp.body.image.url}
                            filename: ${imageResp.body.image.filename}
                            metadata:
                              format: ${imageResp.body.image.format}
                              size: ${imageResp.body.image.size}
            
            # 8. Mark run completed
            - clearContext:
                call: http.request
                args:
                  url:    ${baseUrl + "/ai/text/context/clear"}
                  method: POST
                  auth:   { type: OIDC }
                  headers:
                    x-api-key: ${apiKey}
                  body:
                    storyId: ${storyId}
                    runId: ${runId}
            - markCompleted:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    status:      "completed"
                    currentStep: "done"
                    endedAt:     ${time.format(sys.now())}

            - return_result:
                return:
                  storyId: ${storyId}
                  runId:   ${runId}
                  status:  "completed"

        except:
          as: wfError
          steps:
            - markFailedRun:
                call: http.request
                args:
                  url:    ${baseUrl + "/internal/runs/" + runId}
                  method: PATCH
                  auth:   { type: OIDC }
                  body:
                    status:       "failed"
                    currentStep:  "unknown"
                    errorMessage: ${wfError.message}
                    endedAt:      ${time.format(sys.now())}

            - rethrow:
                raise: ${wfError}